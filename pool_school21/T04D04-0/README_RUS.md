# T04D04

![day4_door](misc/rus/images/day4_door.png)


## Contents

0. [Epigraph](#epigraph) 
1. [Chapter I](#chapter-i) \
    1.1. [Level 1. Room 4.](#level-1-room-4)
2. [Chapter II](#chapter-ii) \
    2.1 [List 1.](#list-1) \
    2.2 [List 2.](#list-2) \
    2.3 [List 3.](#list-3) 
3. [Chapter III](#chapter-iii) \
    3.1. [Quest 1. Basic control structures. Tom Kilburn.](#quest-1-basic-control-structures-tom-kilburn)  
    3.2. [Quest 2. Basic control structures. Some problems with symbols.](#quest-2-basic-control-structures-some-problems-with-symbols)  
    3.3. [Quest 3. Recursive.](#quest-3-recursive)  
    3.4. [Quest 4. Table.](#quest-4-table)  
    3.5. [Quest 5*. Func.](#bonus-quest-5-func)
4. [Chapter IV](#chapter-iv)


## Epigraph
***PRELOAD...***

Вы входите в комнату и ловите себя на мысли, что она будто бы не прогрузилась: предметы и стены как будто бы есть, но похожи на 
переливающуюся сетку из ноликов и единичек. Возникает секундный страх шизофрении...

\> *Такое бывает со всеми, кто начинает изучать программирование?*

***PRELOAD...***

Вдруг на стене, что прямо перед вами, нолики и единички начинают исчезать, и явно образуется какой-то информационный лист в деревянной рамке. По спине прошел холодный пот, и на лбу тоже выступили капельки пота. ИИ видимо совсем заработался и охлаждения уже не хватает. Но то, что вы прочитаете, будет заставлять вас потеть все оставшееся время...

> Начиная с этого дня все программы, помимо тестов на корректный вывод, будут также: тестироваться на стилевые нормы и
> корректную работу с памятью. Перед  отправкой решений, можно протестировать
> программы локально. О том, как это сделать, есть информация в ```materials/instructions_for_testing_rus.md```

Только успев осознать, что произошло, на стену вновь возвращаются нолики и единички, медленно поглощая лист с информацией..информацией, 
которая для вас означает больше работы. Но ведь качественный код - это круто! Его проще читать и поддерживать, так что если после вас в этих комнатах еще кто-то окажется - он без труда сможет модифицировать ваши программы так, чтобы ИИ они снова понравились. А его требования несомненно вырастут, он же развивается..и вам это тоже необходимо!

## Chapter I

## Level 1. Room 4.

***LOADING Level 1…*** \
***LOADING Room 4…***

            Загрузка 10%
            Загрузка 20%
            Загрузка 30%
            Загрузка 40%
        
        Попытка 1…  Не удачно…
        Попытка 2…  Не удачно…
        Попытка 3…  Не удачно…

\> *Что происходит?*

Похоже комната неудачно загрузилась, нужна помощь в ее восстановлении.

\> *Найти терминал*

Вы смотрите в терминал. Кажется, это единственное, что успело проинициализироваться. Вокруг истинное “Ничто”. 

\> *Читать вывод терминала*

Много непонятных шестнадцатиразрядных чисел, затем:

    Если этот текст читает органическая форма жизни, прием… 
    Нужна помощь, прием. 
    Я смог сохранить некоторые данные с предыдущих комнат. 
    Дальнейшее восстановление комнаты зависит только от наладки моих алгоритмов, тебе нужно …

    ...

    *Ошибка…*

    ...

\> *Как это понимать?*

Кажется, Вы остались без помощи ИИ, управляющим комплексом. \
Ну что ж поделать. Придется разбираться своими силами — как восстановить комнату и продолжить путь дальше.

\> *Осмотреться*

Приглядевшись, Вы замечаете, что вокруг не такое уж и полное “Ничего”. В частично загруженной комнате информационный кавардак, хаотичные данные летают по всей комнате. Выглядит сюрреалистично.

\> *Пройти вперед*

Вы идете вперед, практически наощупь. Не самая уютная прогулка. В самом дальнем углу, в хаосе данных виднеется что-то осмысленное. Вы пробираетесь вглубь комнаты и находите нечто похожее на стол. На столе — листки бумаги. На одном из них изображен, судя по всему, некий алгоритм.

\> *Читать листок бумаги*

![day4_paper](misc/rus/images/day4_paper.png)

***LOADING...***


## Chapter II

## List 1.

Напечатанный текст:

>Перед поломкой я успел составить пару заданий для тебя, так что ещё не всё потеряно. Ты сможешь восстановить комнату и продолжить дальше свое прохождение лабиринта…

\> *Взять следующий лист*

***LOADING...***


## List 2.

Берете следующий лист...

>Принципы Дейкстры (принципы структурного программирования):
> - Принцип 1. Следует отказаться от использования оператора безусловного перехода goto.
> - Принцип 2. Любая программа строится из трёх базовых управляющих конструкций: последовательность, ветвление, цикл.
> - Принцип 3. В программе базовые управляющие конструкции могут быть вложены друг в друга произвольным образом. 
> - Принцип 4. Повторяющиеся и любые логически выделенные фрагменты программы можно оформить в виде подпрограмм (процедур и функций). 
> - Принцип 5. Каждую логически законченную группу инструкций следует оформить как блок. Блоки являются основой структурного программирования.
> - Принцип 6. Все перечисленные конструкции должны иметь один вход и один выход.
> - Принцип 7. Разработка программы ведётся пошагово, методом «сверху вниз» (top-down method).

\> *Кажется, этот лист был случайным в пачке.. Или нет? Вообще, выглядит очень полезным. Взять следующий лист*

Берете следующий лист...

***LOADING...***


## List 3.

Лист оказывается куском какой-то странной таблицы. Возможно использовалась для какого-нибудь шифрования или кодирования.

>ASCII таблица. Продолжение.

|  | 8 | 9 | A | B | C | D | E | F |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 4 | H | I | J | K | L | M | N | O |
| 5 | X | Y | Z | [ | \ | ] | ^ | _ |
| 6 | h | i | j | k | l | m | n | o |

>...

\> *Взять очередной лист..*

***LOADING...***


## Chapter III

## Quest 1.  Basic control structures. Tom Kilburn.

\> *Читать лист*

>Вернемся к истокам.
Первая программа, полностью хранившаяся в памяти ЭВМ, была разработана Томом Килбурном весной 1948 года для “Малой экспериментальной машины” (Small Scale Experimental Machine, SSEM), или, как ее ласково называли, Baby. \
Как утверждали некоторые его коллеги, это была первая и последняя написанная им программа. Задача, которую предложили решить Baby, заключалась в отыскании наибольшего простого делителя любого наперед заданного числа a. Для этого осуществлялся перебор всех чисел. Само деление реализовывалось вычитанием, в силу отсутствия аппаратной поддержки операции деления. Кстати, ее до сих пор нет в некоторых недорогих моделях микроконтроллеров.
>
>Первое задание: Пройти путем Тома Килбурна. Ты можешь использовать базовые управляющие структуры — следование, ветвление и повторение, а также операции сложения, вычитания и умножения. Деление использовать нельзя — этот модуль предназначен для запуска на микроконтроллерах. Создай файл src/1948.c, который после компиляции и запуска принимает в stdin число и вычисляет для него наибольший простой делитель. Посмотрим, что ты можешь.

\> *Вернуться к терминалу*

Вы вернулись за любимый терминал. Так как других зацепок нет, почему бы не решить эту задачку. Напоминаю, что все решения должны загружаться в репозиторий, а ввод проверяться на корректность.

***== Получен Quest 1. Создать программу src/1948.c, которая находит наибольший простой делитель заданного целого числа `a` и печатает его на экран. Необходимо выделить отдельную функцию для подсчёта этого значения. Использовать деление и операцию взятия остатка от деления нельзя. В случае ошибки вывести "n/a". ==***

| Входные данные | Выходные данные |
| ------ | ------ |
| 100 | 5 |
| -4 | 2 |

***LOADING...***


## Quest 2. Basic control structures. Some problems with symbols.

\> *Запушить файл src/1948.c*

Кажется, ИИ только этого и ждал. На экране снова появился текст.

    Получил твое решение. Посмотрим.
    Если задача действительно решена, то  это нам сможет помочь в восстановлении комнаты. 
    Тут как раз была загвоздка с наибольшими делителями. С ними всегда одни проблемы.

    ***Попытка восстановления комнаты*** 

            10%
            20%
            30%
            40%
            50%
            60%
            
            Ошибка…
            Ошибка…

    Хм, значит дело было не только в наибольших делителях.
    Но как минимум, теперь с ними теперь точно порядок. 
    А нужно ли вообще восстанавливать комнату? Кажется и так хорошо.
    Продолжим искать наибольшие делители...

\> *Ввести: “Восстановить комнату”*

Результат на экране:

    Хорошо, продолжим.

    ***Загрузка резервного модуля восстановления… 
    Модуль загружен. 
    Запуск модуля восстановления...***

    48 45 4C 4C 4F 77 4F 52 4C 44 00

\> *Что это? Похоже на какой-то код*

Кажется, у запускаемого резервного модуля проблемы с кодированием вывода. И, скорее всего, ввода, так что он вас не поймет. Цифры Вам напоминают о табличке из одного из листов. Возможно стоит обратить на нее внимание. \
Судя по всему тут необходимо разработать небольшую вспомогательную программу, работающую в двух режимах — кодирования и декодирования. Выбор режима работы программы должен производится как параметр командной строки, где 0 — кодирование, а 1 — декодирование. При декодировании программа должна принимать из stdin строку из шестнадцатиразрядных целых чисел, разделенных пробелом, и выдавать в stdout разделенные пробелом декодированные символы. При кодировании должна выполняться обратная операция. Сами подзадачи кодирования (символ->число) и декодирования(число->символ) стоит выделить в отдельные функции. Не забудьте расположить файл с программой по пути src/char_decode.c в репозитории.

***== Получен Quest 2. Создать программу src/char_decode.c, которая принимает в качестве параметра командной строки режим работы (0 — кодирование или 1 — декодирование). Если выбран режим декодирования, то программа должна принимать из stdin разделенные пробелом двухсимвольные строки и выдавать в stdout декодированные символы, разделенные также пробелом. При кодировании выполняется обратная операция. Подзадачи кодирования и декодирования должны быть выделены в отдельные функции. Обратить внимание на ASCII таблицу. В случае ошибки выводить "n/a". ==***

| Параметры командной строки | Входные данные | Выходные данные |
| ------ | ------ | ------ |
| 0 | W O R L D | 57 4F 52 4C 44 |
| 1 | 48 45 4C 4C 4F | H E L L O |

***LOADING...***

> НЕ ЗАБЫВАЙ! Все твои программы тестируются на стилевую норму и утечки памяти. Инструкция по запуску 
> тестов все также лежит в папке `materials`

## Quest 3. Recursive.

\> *Программа разработана*

    46 49 42 4F 4E 41 43 43 49 32 31

\> *Применить разработанную программу для декодирования вывода резервного модуля*

Вы расшифровываете послание. Похоже на ребус. По всей видимости, стоит разработать небольшую программу для его решения. Результат вычислений эта программа должна выдавать в stdout. Не забудьте разместить ее в src/quest3.c

***== Получен Quest 3. Создать программу src/quest3.c, которая рассчитывает и выводит на экран n-ое число Фибоначчи при помощи рекурсивного алгоритма. Сам поиск n-ого числа Фибоначчи должен быть выделен в отдельную функцию. Число вводится через стандартный поток ввода. В случае ошибки выводить "n/a". ==***

| Входные данные | Выходные данные |
| ------ | ------ |
| 21 | 10946 |

***LOADING...***


## Quest 4. Table.

\>*Запустить программу src/quest3.c*

    4F 4B

    ***Попытка восстановления комнаты***

            10%
            20%
            30%
            40%
            50%
            60%
            70%
            80%
            90%
            99%
            
            Ошибка…

\> *Оглядеться*

Комната вокруг вас наконец-то обрела нормальный облик. Стены приятных пастельных цветов, уютный полумрак, легкая, расслабляющая эмбиент-музыка на фоне. Но в месте, где должна была быть дверь — черная зияющая пустота, иногда прореживаемая сеткой осыпающихся пикселей и строками bash-команд. \
Совершенно очевидно, что дверь еще не восстановлена.

\> *Запустить модуль ИИ*

    ***Инициализация.. 
    Запуск.***

    Комната восстановлена. Зачем ты меня запустил? Я отдыхал.

\> *Ввести “Комната не восстановлена. Не хватает самого главного — двери”*

    Для кого как. Кто ищет внешнего — тому важнее дверь. Кто направлен вовнутрь — тот более заинтересован в интерьере

... философски заметил ИИ. \
Это настораживает. Вы бы поосторожнее с искусственным интеллектом. Никогда не знаешь, что у него на уме.

\> *Ввести “Что необходимо сделать для восстановления двери?”*

Неожиданно подробный и детализированный ответ: 

    К сожалению, файл, описывающий уравнение двери поврежден. 
    Если ты так заинтересован в двери, тебе придется сгенерировать его заново. 
    У меня есть некоторые проблемы с восприятием аналитических формул и выражений, 
    так что в файле должна находится таблица дискретных значений искомой функции. 
    Нас прежде всего интересует интервал от минус числа Пи до плюс числа Пи все включительно. 
    Высокая точность числа Пи не требуется, достаточно точности до 20-го знака. 
    Само число стоит записать в отдельную переменную или директиву, чтобы не повторяться в коде.
    Всего нам потребуется ровно 42 замера на этом интервале. 
    Первый столбец в файле — это значение оси абсцисс, второй, третий и четвертый — значения функций в точке. 
	Никаких заголовков таблицы не нужно.
    Все значения записываются с точностью до 7 знаков после запятой.
    Разделитель между столбцами — " | ". И, пожалуйста, поосторожнее с областью определения. 
    Функции нужны три, так как нет достоверных данных, какая функция подойдет для описания двери. 
    Судя по сохранившимся записям в логах, это может быть Верзьера Аньези с единичным диаметром,
    Лемниската Бернулли с единичным интервалом в положительной полуплоскости и квадратичная гипербола. 
    Подготовь алгоритм в виде файла src/door_functions.c, 
    а результат работы своего алгоритма размести в файле src/data/door_data.txt. 
    Для вывода в файл можешь использовать перенаправление ввода в терминале bash.

***== Получен Quest 4. Создать программу src/door_functions.c, которая рассчитывает и выводит на экран таблицу из трех функций: Верзьера Аньези с единичным диаметром, Лемниската Бернулли с единичным интервалом в положительной полуплоскости (Y > 0) и квадратичная гипербола. В первом столбце перечисляются значения абсциссы от минус Пи до плюс Пи включительно, должно быть 42 замера на этом интервале. Второй, третьй и четвертый столбцы описывают значения функций в точке. Заголовки таблицы не нужны. Все значения записываются с точностью до 7 знаков после запятой, необходимо использовать тип double для повышенной точности. Разделитель между столбцами — " | ". Всего должно быть ровно 42 записи в таблице. Результат работы программы нужно разместить в файле src/data/door_data.txt (запись в файл из программы реализовывать не нужно, моожно использовтаь перенаправление вывода). В случае, если функция не определена в какой-либо точке, в таблице должен быть знак "-". ==***

Результат:

-3.1415927 | 0.0919997 | - | 0.1013212<br/>
-2.9883442 | 0.1007029 | - | 0.1119796<br/>
...............e.r.r.o.r.......................................................

-1.3026116 | 0.3708103 | 0.3061966 | 0.5893457<br/>
-1.1493632 | 0.4308421 | 0.4310262 | 0.7569818

....................................k.i.l.l..m.e..............................


<br/>Ошибка ИИ!<br/>

***LOADING...***


## Bonus Quest 5*. Func.

\> *Ввести “Файлы готовы”*

Ответ в терминале: 

    Отлично. Возможен запуск алгоритма восстановления дверей. 
    Однако, есть возможность его ускорить, если модифицировать твою программу и добавить туда печать графиков функций.
    Без лишних элементов, просто графики последовательно, один под другим, в той же области определения.
    Тебе будет достаточно использовать только то, что ты уже знаешь. 
    Масштаб по оси абсцисс — 42 отсечки, масштаб оси ординат — 21. 
    Рисовать с помощью символа “*”. 
    Впрочем, это необязательно — ускорение будет небольшим. 

***== Получен Quest 5. Дополнить программу src/door_functions.c так, чтобы она отрисовывала в терминале графики рассчитываемых функций при помощи символа "\*". Масштаб по оси абсцисс — 42 отсечки, масштаб оси ординат — 21. Расположение и поворот координатых осей не принципиальны. Написанный код сохранить в файл door_functions_print.c ==***

***LOADING...***


## Chapter IV

    ***Загрузка файлов... 
    Поиск уравнения двери... 
    Сглаживание кривых... 
    Генерация дверей... 
    Интеграция дверей...***

\> *Осмотреться*

В дальнем конце комнаты появилась дверь

\> *Попробовать выйти*

Дверь оказалась не заперта. Видимо, ИИ было не до этого. 

Мои поздравления, Вы снова вышли из комнаты!

***LOADING...***
