# T10D16

![This day will help you get acquainted with characters and strings (C).](misc/rus/images/day10_door.png)


## Contents

1. [Chapter I](#chapter-i) \
 1.1. [Level 3. Room 2.](#level-3-room-2)
2. [Chapter II](#chapter-ii) \
    2.1. [List 1.](#list-1) \
    2.2. [List 2.](#list-2) 
3. [Chapter III](#chapter-iii) \
 3.1. [Quest 1. Strlen.](#quest-1-strlen) \
 3.2. [Quest 2. Strcmp.](#quest-2-strcmp) \
 3.3. [Quest 3. Strcpy.](#quest-3-strcpy) \
 3.4. [Quest 4. Strcat.](#quest-4-strcat) \
 3.5. [Quest 5. Strchr.](#quest-5-strchr) \
 3.6. [Quest 6. Strstr.](#quest-6-strstr) \
 3.7. [Quest 7. Strtok.](#quest-7-strtok) \
 3.8. [Quest 8. Width.](#quest-8-width) 
4. [Chapter IV](#chapter-iv) 


# Chapter I

## Level 3. Room 2.

***LOADING Level 3… \
LOADING Room 2…***

Вы попадаете в прекрасно меблированную комнату с большим количеством книжных полок. Куда не посмотреть - всюду книги. Рядом с дверью - книги. Даже компьютер стоит на стопке книг.

![day10_book](misc/rus/images/day10_book.png)

\> *Сесть за компьютер, запустить модуль и нажать Enter*

Вы видите на экране следующие строки:

    1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

    Аварийное сообщение: недоступны стандартные вызовы библиотеки string.h. 
    Работа модуля лингвистики невозможна.

\> *find -O3 -L / -name "string.h"*

Прождав n часов времени, Вы понимаете, что данной библиотеки попросту **нет** на компьютере.

\> *Дернуть ручку двери*

Не поддается.

\> *Отлично, похоже теперь еще придется восстанавливать эту библиотеку!*

Ваш взгляд падает на многочисленные книги в комнате. Вы замечаете, что названия книг на корешке находятся в алфавитном порядке.\
Похоже на старую компьютерную литературу и распечатки мануалов. \
Что-то внутри Вас подсказывает поискать книгу, связанную с библиотекой string.h

\> *Поиск...*

Неудача.

\> *Поиск...*

Неудача.

\> *Поиск...*

Удача. Вы находите книгу с говорящим названием: "The String.h - Linux manual. Complete edition."

\> *Открыть книгу*

Очень похоже на распечатку man-a. Даже шрифт как в терминале. 

***LOADING...***


# Chapter II

## List 1.

\> *Читать книгу*

    PROLOG
       This manual page is part of the POSIX Programmer's Manual.  The Linux
       implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.
    NAME 
       string.h — string operations
    SYNOPSIS
       #include <string.h>
    DESCRIPTION
       Some of the functionality described on this reference page extends
       the ISO C standard. Applications shall define the appropriate feature
       test macro (see the System Interfaces volume of POSIX.1‐2008, Section
       2.2, The Compilation Environment) to enable the visibility of these
       symbols in this header.

       The <string.h> header shall define NULL and size_t as described in
       <stddef.h>.

       The <string.h> header shall define the locale_t type as described in
       <locale.h>.

       The following shall be declared as functions and may also be defined
       as macros. Function prototypes shall be provided for use with ISO C
       standard compilers.

            Chapter 1 - size_t   strlen(const char *);
            Chapter 2 - int      strcmp(const char *, const char *);
            Chapter 3 - char    *strcpy(char *restrict, const char *restrict);
            Chapter 4 - char    *strcat(char *restrict, const char *restrict);
            Chapter 5 - char    *strchr(const char *, int);
            Chapter 6 - char    *strstr(const char *, const char *);
            Chapter 7 - size_t   strnlen(const char *, size_t);
            Chapter 8 - int      strncmp(const char *, const char *, size_t);
          
            ...

       Inclusion of the <string.h> header may also make visible all symbols
       from <stddef.h>.

Сколько же функций содержит эта библиотека... Возможно стоит пойти итеративным путем и после добавления каждой новой функции пытаться перезапускать программный модуль. Может ему требуются не все функции.. 
Иначе можно застрять надолго.

\> *Снова подойти к компьютеру*

Подойдя к компьютеру, Вы замечаете рядом с ним очередную открытую книгу, которую почему-то пропустили при первом подходе. Книга открыта на главе "Модульное тестирование: Часть 2"

\> *Пробежаться глазами*

***LOADING...***


## List 2.

>Модульное тестирование (англ. unit testing) - процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы, 
>наборы из одного или более программных модулей вместе с соответствующими управляющими данными, процедурами использования и обработки.
>Идея состоит в том, чтобы разрабатывать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное 
>изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных частях программы, а также облегчает обнаружение и устранение таких ошибок.
>Цель модульного тестирования — изолировать отдельные части программы и показать, что по отдельности эти части работоспособны, минимизировав число состояний системы.

***LOADING...***


# Chapter III

## Quest 1. Strlen.

Возможно, стоит дополнительно написать тесты для каждой новой функции, чтобы удостовериться, что они работают полностью корректно. Кто знает, как может повлиять сломанный код на и так не работающий модуль лингвистики. А Вам все еще нужно выбраться из этой комнаты. К тому же, если что-то пойдет не так, с тестами будет проще искать ошибку. 

На каждую добавленную функцию в src/s21_string.h нужно добавить в файл src/s21_string_test.h тест, разработанный согласно идее модульного тестирования, с названием функции и постфиксом _test, который проверяет функцию на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводить вход, выход и результат теста (SUCCESS/FAIL). 

> НЕ ЗАБЫВАЙ! Все твои программы тестируются на стилевую норму и утечки памяти. Инструкция по запуску 
> тестов все также лежит в папке `materials`

***== Получен Quest 1. Создать файлы src/s21_string.h и src/s21_string.c и добавить в них объявление и определение функции s21_strlen. Создать тестовую программу src/s21_string_test.c, куда добавить функцию s21_strlen_test для проверки функции s21_strlen на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводится вход, выход и результат теста (SUCCESS/FAIL). В main разместить запуск этой функции. При разработке функции s21_strlen использовать только средства языка, использовать string.h и другие библиотеки нельзя. Сборку программы осуществлять при помощи Makefile. Имя стадии сборки - strlen_tests. Исполняемый файл должен храниться в корне в папке build с именем Quest_1. ==***

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


## Quest 2. Strcmp.

\> *Первая функция готова.*

\> *Перезапуск модуля*

    1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    11111111111111111111111111111111111111111111111111111111111111111111111111111111111

    Аварийное сообщение: недоступны стандартные вызовы библиотеки string.h. Работа модуля лингвистики невозможна.

Продолжаем..

***== Получен Quest 2.  Добавить объявление и определение функции s21_strcmp в файлы src/s21_string.h и src/s21_string.c. Добавить функцию s21_strcmp_test в файл src/s21_string_test.c для проверки функции s21_strcmp на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводится вход, выход и результат теста (SUCCESS/FAIL). В main добавить запуск этой функции. При разработке функции s21_strcmp использовать только средства языка, использовать string.h и другие библиотеки нельзя. Сборку программы осуществлять при помощи Makefile. Имя стадии сборки - strcmp_tests. Исполняемый файл должен храниться в корне в папке build с именем Quest_2. ==***

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


## Quest 3. Strcpy.

\> *Вторая есть.*

\> *Перезапуск*

    1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    1111111111111111111111111111111111111111111111111111111111111111
    
    Аварийное сообщение: недоступны стандартные вызовы библиотеки string.h. Работа модуля лингвистики невозможна.

***== Получен Quest 3.  Добавить объявление и определение функции s21_strcpy в файлы src/s21_string.h и src/s21_string.c. Добавить функцию s21_strcpy_test в файл src/s21_string_test.c для проверки функции s21_strcpy на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводится вход, выход и результат теста (SUCCESS/FAIL). В main добавить запуск этой функции. При разработке функции s21_strcpy использовать только средства языка, использовать string.h и другие библиотеки нельзя. Сборку программы осуществлять при помощи Makefile. Имя стадии сборки - strcpy_tests. Исполняемый файл должен храниться в корне в папке build с именем Quest_3. ==***

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


## Quest 4. Strcat.

\> *Проверка модуля*

    1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    11111111111111111111111111111111111111
    
    Аварийное сообщение: недоступны стандартные вызовы библиотеки string.h. Работа модуля лингвистики невозможна.

***== Получен Quest 4. Добавить объявление и определение функции s21_strcat в файлы src/s21_string.h и src/s21_string.c. Добавить функцию s21_strcat_test в файл src/s21_string_test.c для проверки функции s21_strcat на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводится вход, выход и результат теста (SUCCESS/FAIL). В main добавить запуск этой функции. При разработке функции s21_strcat использовать только средства языка, использовать string.h и другие библиотеки нельзя. Сборку программы осуществлять при помощи Makefile. Имя стадии сборки - strcat_tests. Исполняемый файл должен храниться в корне в папке build с именем Quest_4. ==***

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


## Quest 5. Strchr.

\> *Очередная унылая проверка модуля*

    1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    11111

    Аварийное сообщение: недоступны стандартные вызовы библиотеки string.h. Работа модуля лингвистики невозможна.

***== Получен Quest 5. Добавить объявление и определение функции s21_strchr в файлы src/s21_string.h и src/s21_string.c. Добавить функцию s21_strchr_test в файл src/s21_string_test.c для проверки функции s21_strchr на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводится вход, выход и результат теста (SUCCESS/FAIL). В main добавить запуск этой функции. При разработке функции s21_strchr использовать только средства языка, использовать string.h и другие библиотеки нельзя. Сборку программы осуществлять при помощи Makefile. Имя стадии сборки - strchr_tests. Исполняемый файл должен храниться в корне в папке build с именем Quest_5. ==***

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


## Quest 6. Strstr.

\> *Проверяем...*

    1111111111111111111111111111111111111111111111111111111111111111111111111111
    
    Аварийное сообщение: недоступны стандартные вызовы библиотеки string.h. Работа модуля лингвистики невозможна.
    
Сколько же вызовов использует этот модуль?
    
***== Получен Quest 6.  Добавить объявление и определение функции s21_strstr в файлы src/s21_string.h и src/s21_string.c. Добавить функцию s21_strstr_test в файл src/s21_string_test.c для проверки функции s21_strstr на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводится вход, выход и результат теста (SUCCESS/FAIL). В main добавить запуск этой функции. При разработке функции s21_strstr использовать только средства языка, использовать string.h и другие библиотеки нельзя. Сборку программы осуществлять при помощи Makefile. Имя стадии сборки - strstr_tests. Исполняемый файл должен храниться в корне в папке build с именем Quest_6. ==***

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


## Quest 7. Strtok.

\> *Снова*

    11111111111111111111111111111111
    111111111
    111
    
    Загрузка...
    Подгрузка...
    Подкачка...
    Готово.
    
    Данные модуля загружены успешно, модуль готов к запуску.

Наконец!

\> *Подтвердить запуск модуля*

    Запуск справочного модуля...
    ОК!
    
    Справочный модуль к Вашим услугам, чем могу помочь?

\> *Ввести "Мне необходимо пройти дальше"*

    Разбиение вопроса - провалено
    
    Аварийное сообщение: недоступны расширенные вызовы библиотеки string.h - функция strtok не найдена.
    
Да что же такое. Похоже нужно добавить еще и эту функцию в библиотеку.

***== Получен Quest 7. Добавить объявление и определение функции s21_strtok в файлы src/s21_string.h и src/s21_string.c. Добавить функцию s21_strtok_test в файл src/s21_string_test.c для проверки функции s21_strtok на наборе тестовых данных (от 3-х): нормальные значения, ненормальные значения, краевые значения и т.д. По каждому тесту в stdout выводится вход, выход и результат теста (SUCCESS/FAIL). В main добавить запуск этой функции. При разработке функции s21_strtok использовать только средства языка, использовать string.h и другие библиотеки нельзя. Сборку программы осуществлять при помощи Makefile. Имя стадии сборки - strtok_tests. Исполняемый файл должен храниться в корне в папке build с именем Quest_7. ==***

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


## Quest 8. Width.

\> *Перезапуск модуля*

    Запуск справочного модуля...
    ОК!
    
    Справочный модуль к Вашим услугам, чем могу помочь?
    
\> *Ввести "Мне необходимо пройти дальше"*

    Проход дальше - распознано
    Поиск информации по базе данных... ... ...
    
    Данные по ключу для комнаты 3-2:
    Для разблокировки двери в комнате 3-2 необходимо внести посильную лепту в разрабатываемый программный комплекс
    по обработке текстов. Сканирование доступных тикетов......
    ..............................................................
    ..............................................................
    ..............................................................
    Найден тикет. Составить программу src/text_processor.c с полным функционалом текстового процессора. 
    Источники для вдохновения: MS Word, LibreOffice, OpenOffice.

\> *Ввести "Эм. Это, кажется, перебор."*

    Анализ ответа.... Ответ проанализирован.
    Характеристики ответа: сарказм, боль, уныние, недоверие, испуг, отказ.
    Поиск компромисса....
    Компромисс найден: нужно реализовать не всю задачу, а ее часть.
    Составить программу src/text_processor.c, которая работает только в одном режиме 
    с ключом -w (форматирование по ширине), принимая число и текст до 100 символов через stdin.
    Как результат она должна сформировать и затем вывести входной текст, отформатированный по ширине. 
    Сама ширина строки текста в символах задается первым числом. 
    Задание окончательное и обжалованию не подлежит.
    После обновления удаленного репозитория комнаты, дверь будет разблокирована.
    
Окей. Это не самое худшее, что Вы делали для открытия дверей.

***== Получен Quest 8. Создать программу src/text_processor.c, которая при запуске с ключом командной строки -w принимает на вход в stdin число (ширину строки) и текст до 100 символов, оканчивающийся символом переноса строки. При любых других ключах программа должна выводить "n/a". Скомпилированный файл должен называться Quest_8. При запуске с ключом -w, программа форматирует входной текст по ширине и выводит в stdout, имитируя поведение текстового процессора. Текст должен быть разбит на несколько строк, каждая из которых состоит из указанного количества символов. Строки не могут начинаться с пробела и не могут заканчиваться пробелом, последняя строка не должна оканчиваться знаком переноса строки. Слово может быть разбито для перехода на новую строку через символ '-' только, если целиком не помещается на одной строке. Во всех других случаях оно должно оставаться целым. Слова в строке размещать равномерно, заполняя пространство между ними пробелами. Использовать string.h нельзя. ==***

| Параметры командной строки | Входные данные | Выходные данные |
| ------ | ------ | ------ |
| -w | 10<br/>hello how are you | hello how<br/>are you |
| -w | 5<br/>ab abcd ab abcd ab abcdefgh | ab<br/>abcd<br/>ab<br/>abcd<br/>ab a-<br/>bcde-<br/>fgh |

> Разрешено пользоваться только следующими стандартными библиотеками: <stdlib.h>, <stdio.h>

***LOADING...***


# Chapter IV

\> *Ввести "Теперь я могу выйти?"*

    Все условия для выхода: выполнены.
    Осталось последнее.
    Давайте поговорим.

\> *Ввести "Может быть, в другой раз...?"*

    Ваш ответ был предсказан предиктивным алгоритмом с точностью 91%.
    Спасибо за содержательную беседу и помощь в валидации предиктивной лингвистической аналитики.
    Всего доброго.
    Откртытие двери.... 
    
Раздался щелчок и дверь открылась настежь, как на пружинах. Пора в путь! 

***LOADING...***

